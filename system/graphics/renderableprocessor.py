import logging
import esper

from messaging import messaging, MessageType
from config import Config
from directmessaging import directMessaging, DirectMessageType
import system.gamelogic.attackable
import system.gamelogic.enemy
import system.gamelogic.player
from system.graphics.renderable import Renderable
import system.groupid
from texture.texturetype import TextureType
from system.singletons.renderablecache import renderableCache

logger = logging.getLogger(__name__)


class RenderableProcessor(esper.Processor):
    def __init__(self, textureEmiter, particleEmiter):
        super().__init__()
        self.textureEmiter = textureEmiter
        self.particleEmiter = particleEmiter

        # list of HEIGHT lists
        # used to add renderable objects in the right Z order for render()
        # 5 is an arbitrary number
        self.renderOrder = [[] for i in range(Config.rows + 5)]


    def process(self, dt):
        # TODO which one first?
        self.removeInactiveRenderables()
        self.advance(dt)
        self.renderRenderables()
        self.renderParticles()
        self.makeSpeechBubble()
        self.checkClearRenderables()


    def checkClearRenderables(self):
        for message in messaging.getByType(MessageType.ClearRenderables):
            for ent, rend in self.world.get_component(Renderable):
                renderableCache.addRenderable(rend, rend.texture.type)
                logger.info("Remove Entity A: {}".format(ent))
                self.world.delete_entity(ent)


    def makeSpeechBubble(self):
        for msg in directMessaging.getByType(DirectMessageType.activateSpeechBubble):
            for ent, (renderable, groupId) in self.world.get_components(
                system.graphics.renderable.Renderable,
                system.groupid.GroupId
            ):
                if groupId.getId() == msg.groupId:
                    self.textureEmiter.showSpeechBubble(
                        displayText=msg.data['text'],
                        time=msg.data['time'],
                        parentRenderable=renderable
                    )


    def advance(self, deltaTime):
        for _, rend in self.world.get_component(Renderable):
            rend.advance(deltaTime)


    def removeInactiveRenderables(self):
        for ent, rend in self.world.get_component(Renderable):
            if rend.texture.isActive() is False:
                # generated by TextureEmiter.makeActionTexture
                if rend.texture.type is TextureType.action:
                    renderableCache.addRenderable(rend, rend.texture.type)
                    logger.info("Remove Entity B: {}".format(ent))
                    self.world.delete_entity(ent)

                # generated by TextureEmiter.makePhenomenaTexture
                if rend.texture.type is TextureType.phenomena:
                    renderableCache.addRenderable(rend, rend.texture.type)
                    logger.info("Remove Entity C: {}".format(ent))
                    self.world.delete_entity(ent)


    def renderRenderables(self):
        for l in self.renderOrder:
            l.clear()

        # add all elements to draw in the correct Z order
        # which is by y coordinates
        for _, rend in self.world.get_component(Renderable):
            if rend.isActive():
                # logger.info("REND: {} {} {}".format(rend, rend.z, rend.coordinates))
                loc = rend.getLocation()
                if rend.z > 0:
                    self.renderOrder[rend.z].append(rend)
                else:
                    self.renderOrder[loc.y].append(rend)

        for l in self.renderOrder:
            for rend in l:
                rend.draw()


    def renderParticles(self):
        # render particles too
        for particle in self.particleEmiter.particleActive:
            particle.draw()
